/*
 * This file is part of Dependency-Track.
 *
 * Dependency-Track is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * Dependency-Track is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Dependency-Track. If not, see http://www.gnu.org/licenses/.
 */
package org.owasp.dependencytrack.dao;

import org.hibernate.*;
import org.hibernate.criterion.ProjectionList;
import org.hibernate.criterion.Projections;
import org.hibernate.criterion.Restrictions;
import org.owasp.dependencytrack.model.*;
import org.owasp.dependencytrack.tasks.DependencyCheckAnalysisRequestEvent;
import org.owasp.dependencytrack.util.session.DBSessionTask;
import org.owasp.dependencytrack.util.session.DBSessionTaskReturning;
import org.owasp.dependencytrack.util.session.DBSessionTaskRunner;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;

@Repository("vulnerabilityDao")
@SuppressWarnings("unchecked")
public class VulnerabilityDaoImpl extends DBSessionTaskRunner implements VulnerabilityDao {

	/**
	 * Setup logger
	 */
	private static final Logger LOGGER = LoggerFactory
			.getLogger(VulnerabilityDaoImpl.class);

	/**
	 * Event publisher
	 */
	private ApplicationEventPublisher eventPublisher;

	/**
	 * Default constructor. Used when class is automatically created and
	 * SessionFactory is autowired.
	 */
	public VulnerabilityDaoImpl()
	{
	}

	/**
	 * Constructer used when class is manually created.
	 * 
	 * @param sessionFactory
	 *            a Hibernate SessionFactory
	 */
	public VulnerabilityDaoImpl(SessionFactory sessionFactory)
	{
		this.sessionFactory = sessionFactory;
	}

	/**
	 * Returns a list of Vulnerability objects for LibraryVersions that have a
	 * dependency of the specified ApplicationVersion.
	 *
	 * @param applicationVersion
	 *            The ApplicationVersion to retrieve vulnerability for
	 * @return a List of Vulnerability objects
	 */
	@Override
	@SuppressWarnings("unchecked")
	public List<VulnerableComponent> getVulnerableComponents(
			final ApplicationVersion applicationVersion)
	{

		return dbRun(new DBSessionTaskReturning<List<VulnerableComponent>>() {
			@Override
			public List<VulnerableComponent> run(Session session) {
				final List<VulnerableComponent> vulnerableComponents = new ArrayList<>();
				// Retrieve all of the library versions from the specified application
				// version
				final List<LibraryVersion> libvers = new ArrayList<>();
				final Query query = session
						.createQuery("from ApplicationDependency where applicationVersion=:version");
				query.setParameter("version", applicationVersion);
				final List<ApplicationDependency> deps = query.list();

				for (ApplicationDependency dep : deps)
				{
					libvers.add(dep.getLibraryVersion());
				}

				// Iterate through the library versions looking for scan
				// results
				for (LibraryVersion libraryVersion : libvers)
				{
					final Criteria criteria = session
							.createCriteria(ScanResult.class);
					criteria.add(Restrictions.eq("libraryVersion",
							libraryVersion));
					final ProjectionList projList = Projections
							.projectionList();
					projList.add(Projections.property("libraryVersion"));
					projList.add(Projections.property("vulnerability"));
					criteria.setProjection(Projections
							.distinct(projList));
					final List<Object[]> results = criteria.list();
					final List<Vulnerability> vulns = new ArrayList<>();

					for (Object[] result : results)
					{
						for (Object object : result)
						{
							if (object instanceof Vulnerability)
							{
								vulns.add((Vulnerability) object);
							}
						}
					}

					final VulnerableComponent vulnerableComponent = new VulnerableComponent();
					vulnerableComponent
							.setLibraryVersion(libraryVersion);
					vulnerableComponent.setVulnerabilities(vulns);
					// Add the VulnerableComponent to the list of
					// vulnerableComponents to return
					vulnerableComponents.add(vulnerableComponent);
				}
				return vulnerableComponents;
			}
		});


	}

	@Override
	public List<VulnerabilitySummary> getVulnerabilitySummary(final int id)
	{
		return dbRun(new DBSessionTaskReturning<List<VulnerabilitySummary>>() {
			@Override
			public List<VulnerabilitySummary> run(Session session) {

				final List<VulnerabilitySummary> summaryList = new ArrayList<>();
				final Query query = session.createQuery(
						"from Application where id=:id");
				query.setParameter("id", id);
				final List<Application> applications = query.list();
				for (Application application : applications)
				{
					for (ApplicationVersion version : application.getVersions())
					{
						summaryList.add(getVulnerabilitySummary(version));
					}
				}
				return summaryList;
				
			}
		});
	}

	@Override
	public VulnerabilitySummary getVulnerabilitySummary(
			final ApplicationVersion applicationVersion)
	{
		return dbRun(new DBSessionTaskReturning<VulnerabilitySummary>() {
			@Override
			public VulnerabilitySummary run(Session session) {
				final List<VulnerableComponent> vulnerableComponents = getVulnerableComponents(applicationVersion);

				final VulnerabilitySummary vulnerabilitySummary = new VulnerabilitySummary();
				vulnerabilitySummary.setApplicationVersion(applicationVersion);
				vulnerabilitySummary.setVulnerableComponents(vulnerableComponents
						.size());

				for (VulnerableComponent vulnerableComponent : vulnerableComponents)
				{
					final List<Vulnerability> vulnerabilities = vulnerableComponent
							.getVulnerabilities();

					for (Vulnerability vulnerability : vulnerabilities)
					{

						if (vulnerability.getSeverity() == Vulnerability.Severity.HIGH)
						{
							vulnerabilitySummary
									.setHigh(vulnerabilitySummary.getHigh() + 1);
						} else if (vulnerability.getSeverity() == Vulnerability.Severity.MEDIUM)
						{
							vulnerabilitySummary.setMedium(vulnerabilitySummary
									.getMedium() + 1);
						} else if (vulnerability.getSeverity() == Vulnerability.Severity.LOW)
						{
							vulnerabilitySummary
									.setLow(vulnerabilitySummary.getLow() + 1);
						}

					}
				}
				return vulnerabilitySummary;
			}
		});
	}

	@Override
	public List<Vulnerability> getVulnsForLibraryVersion(
			final LibraryVersion libraryVersion)
	{
		return dbRun(new DBSessionTaskReturning<List<Vulnerability>>() {
			@Override
			public List<Vulnerability> run(Session session) {
				final Criteria criteria = session
						.createCriteria(ScanResult.class);
				criteria.add(Restrictions.eq("libraryVersion", libraryVersion));
				final ProjectionList projList = Projections.projectionList();
				projList.add(Projections.property("libraryVersion"));
				projList.add(Projections.property("vulnerability"));
				criteria.setProjection(Projections.distinct(projList));
				final List<Object[]> results = criteria.list();
				final List<Vulnerability> vulns = new ArrayList<>();

				for (Object[] result : results)
				{
					for (Object object : result)
					{
						if (object instanceof Vulnerability)
						{
							vulns.add((Vulnerability) object);
						}
					}
				}

				return vulns;
			}
		});
	}

	/**
	 * Performs a series of queries to obtain scan result history for the
	 * specified timespan and constructs a VulnerabilityTrend object with
	 * historical vulnerability data.
	 * 
	 * @param timespan
	 *            the timespan to perform the query on (i.e. last 30, 60, 90,
	 *            365 days)
	 * @param appVersionId
	 *            todo future use
	 * @return a VulnerabilityTrend object containing historical data
	 */
	@Override
	public VulnerabilityTrend getVulnerabilityTrend(
			final VulnerabilityTrend.Timespan timespan, int appVersionId)
	{
		return dbRun(new DBSessionTaskReturning<VulnerabilityTrend>() {
			@Override
			public VulnerabilityTrend run(Session session) {
				final Map<Date, VulnerabilitySummary> map = new LinkedHashMap<>();

				// Get the start date and end date for retrieving result info
				final Calendar startDate = Calendar.getInstance();
				final Calendar endDate = Calendar.getInstance();
				startDate.add(Calendar.DAY_OF_MONTH, -timespan.getDays());

				// Using the date range above, check to see how many datapoints are in
				// that range
				final Query dateQuery = session
						.createQuery("select distinct s.scanDate from ScanResult s where s.scanDate >= ? and s.scanDate <= ? order by s.scanDate asc");
				dateQuery.setParameter(0, startDate.getTime());
				dateQuery.setParameter(1, endDate.getTime());
				final List<Date> dates = dateQuery.list();
				final int numDates = dates.size();

				final List<Date> dataPointDates = new ArrayList<>();
				if (numDates < timespan.getDivisions())
				{
					dataPointDates.addAll(dates);
				} else
				{
					final int dataPoints = timespan.getDivisions();
					final double sliceEvery = ((double) dates.size() / (double) dataPoints);
					int sliceEveryProgress = 0;
					for (int i = 0; i < dataPoints; i++)
					{
						if (i == 0)
						{ // Always include the first date from the results
							dataPointDates.add(dates.get(0));
						} else if (i == (dataPoints - 1))
						{ // Always include the last date from the results
							dataPointDates.add(dates.get(dates.size() - 1));
						} else if (sliceEveryProgress >= i)
						{ // Include everything in between
							dataPointDates.add(dates.get(i));
						}
						sliceEveryProgress += sliceEvery;
					}
				}
				// Iterate for the number of datapoints we're going to eventually
				// present
				for (Date dataPointDate : dataPointDates)
				{
					final Query query = session
							.createQuery("select distinct s from ScanResult s where s.scanDate = ?");
					query.setParameter(0, dataPointDate);
					final List<ScanResult> scanResults = query.list();
					for (ScanResult scanResult : scanResults)
					{
						addVulnerabilityToTrend(map, scanResult);
					}
				}
				final VulnerabilityTrend trend = new VulnerabilityTrend();
				final Set<Date> keys = map.keySet();
				for (Date date : keys)
				{
					trend.addData(date, map.get(date));
				}
				return trend;
			}
		});
	}

	/**
	 * Adds the specified scan result to a growing map
	 * 
	 * @param map
	 *            a map of VulnerabilitySummary object using Date as the key
	 * @param scanResult
	 *            a ScanResult object
	 */
	@Transactional
	private void addVulnerabilityToTrend(Map<Date, VulnerabilitySummary> map,
			ScanResult scanResult)
	{
		final Date scanDate = scanResult.getScanDate();
		final Vulnerability vulnerability = scanResult.getVulnerability();
		VulnerabilitySummary summary = map.get(scanDate);
		if (summary == null)
		{
			summary = new VulnerabilitySummary();
			map.put(scanDate, summary);
		}
		final Vulnerability.Severity severity = vulnerability.getSeverity();
		if (Vulnerability.Severity.HIGH == severity)
		{
			summary.addHigh();
		} else if (Vulnerability.Severity.MEDIUM == severity)
		{
			summary.addMedium();
		} else if (Vulnerability.Severity.LOW == severity)
		{
			summary.addLow();
		}
	}

	@Override
	public void initiateFullDependencyCheckScan()
	{
		dbRun(new DBSessionTask() {
			@Override
			public void run(Session session) {
				final Query query = session.createQuery(
						"from LibraryVersion");
				final List<LibraryVersion> libraryVersions = query.list();
				eventPublisher
						.publishEvent(new DependencyCheckAnalysisRequestEvent(
								libraryVersions));
			}
		});
	}

	public void setApplicationEventPublisher(
			ApplicationEventPublisher applicationEventPublisher)
	{
		this.eventPublisher = applicationEventPublisher;
	}

	/**
	 * Update the vulnerability count in all ApplicationVersion objects.
	 */
	@Override
	@Transactional(rollbackFor = Exception.class)
	public void updateApplicationVersionVulnerabilityCount()
	{
		dbRun( new DBSessionTaskReturning<Integer>()
		{

			@Override
			public Integer run(Session session)
			{
				final Query appVerQuery = session
						.createQuery("FROM ApplicationVersion ");
				final List<ApplicationVersion> applicationVersions = appVerQuery
						.list();
				for (ApplicationVersion applicationVersion : applicationVersions)
				{
					final Query depQuery = session
							.createQuery(
									"from ApplicationDependency where applicationVersion=:version");
					depQuery.setParameter("version", applicationVersion);

					int appVulnCount = 0;
					final List<ApplicationDependency> dependencies = depQuery
							.list();
					for (ApplicationDependency dependency : dependencies)
					{
						final LibraryVersion libraryVersion = dependency
								.getLibraryVersion();
						appVulnCount += libraryVersion.getVulnCount();
					}
					applicationVersion.setVulnCount(appVulnCount);
					session.save(applicationVersion);
				}
				return null;
			}
		});

	}

	/**
	 * Update the vulnerability count in all LibraryVersion objects.
	 */
	@Override
	@Transactional(rollbackFor = Exception.class)
	public void updateLibraryVersionVulnerabilityCount()
	{
		dbRun( new DBSessionTask()
		{

			@Override
			public void run(Session session)
			{
				final Query libverQuery = session
						.createQuery("FROM LibraryVersion");
				final List<LibraryVersion> libraryVersions = libverQuery.list();
				for (LibraryVersion libraryVersion : libraryVersions)
				{
					final SQLQuery vulnQuery = session
							.createSQLQuery(
									"SELECT DISTINCT vulnerabilityid FROM scanresult WHERE libraryversionid=:libraryVersion");

					vulnQuery.setParameter("libraryVersion",
							libraryVersion.getId());
					final int vulnCount = vulnQuery.list().size();
					libraryVersion.setVulnCount(vulnCount);
					session.save(libraryVersion);
				}
			}
		});
	}

}
